**黑神话悟空写实画面游戏的技术探索之路**
=================

这个视频是免费的.https://edu.uwa4d.com/course-intro/1/196.
(Github正常排版: [黑神话悟空写实画面游戏的技术探索之路](TODO:))

------------------------

[1. 打包](#1)<br>
[2. 加载](#2)<br>
[3. 卸载](#3)<br>
[4. 更新](#4)<br>
[5. 实战对比](#5)<br>
[6. 其他](#6)<br>

------------------------
<span id='1'/>

## **1. 真实感**
* ## **真实感不足的原因**
  + 光照组成丢失
    - AO,GI缺失
      - 影中影的问题
      - SSAO没有提供中长距离AO
    - 半透明物体丢失阴影
    - 物体表面微光照无法表达
  + 计算精度不足
    - 实时计算达不到精度
    - 烘焙精度不足
  + 光照效果不正确
    - 光照管线达不到绝对物理光照正确
    - 资源制作不正确
<br/>

* ## **场景区分**
  + 开场场景--晴天
    - 简单容易出效果
    - 有明显的方向光和明亮的天空盒
    - Shadowmap+SSAO足以表达效果
    - 暗部的变化相对不明显,不需要精确计算的AO/GI
  + 开场场景--阴天
    - shadowmap效果被极度弱化
    - skylight的效果极强,但是skylight难计算和表达(可以烘焙或别的方案表达)
    - GI约等于单纯的天光
    - AO表达是关键:影中影,DFAO,物件自身AO
<br/>

* ## **我们要做什么**
  + 引擎做了什么
    - PBR Shading Model
    - Physical Camera
    - physical Light Unit
    - 若干套优缺点的光照方案
  + 我们要做什么
    - 细节光照的表达
    - 超大视距性能和精度
    - 半透明光影和精度
    - 体积光的阴影和精度
    - 资源的物理正确
<br/>

------------------------
<span id='2'/>

## **2. 光照**
* ## **动态光 VS 静态光(为什么要动态光)**
  + Lightmass主要依赖surface lightmap,而volumetric light无法表达精确的表面光照
  + 开放世界surface lightmap 占用内存和容量很大
  + 植被surface lightmap 需求量大和精度大
  + 动态场景--更方便制作场景的运动和破坏效果
  + 迭代效率--烘焙会降低美术迭代效率
<br/>

* ## **距离光照(Distance Field)**
  + 使用距离场表达场景(静态)
    - https://zhuanlan.zhihu.com/p/26217154
    - https://zhuanlan.zhihu.com/p/89701518
    - 空间点到模型的最近的距离,类似光追使用三角面和BVH
    - 两种组织方式:Grid bucket 和 global texture
    - 可以基于ray match实现软阴影/AO(DFAO)/GI等常见功能
  + 优点
    - 性能好,效果远超光追
    - 有空间查询能力,可在Shader中实现复杂的效果
      - 动态flowmap , terrain blend
  + 缺点
    - 精度低
      - 容易出现渲染错误和漏光
      - 细节光照无法表达
<br/>

* ## **动态物体光照**
  + Capsule Shadow
    - https://www.unrealengine.com/zh-CN/blog/chn-unreal-engine-4-light-and-shadow
    - Capsule数据容易存储,ray march中容易计算
    - 实现软间接shadow(支持影中影)
    - 对静态Distance Field的补充
<br/>


* ## **动态管线的TradeOff**
  + 动态管线真的慢吗?
    - Fortnite(堡垒之夜)
    - 取决于使用了什么特性,场景物件的把控
  + 动态效果不如Lightmass吗?
    - 暂时缺乏高品质GI,需要手动补光
    - 合理运用特性(DFAO),AO精度和表达不是问题
  + 灵活运用各种手段
    - DFRTS(用距离场算阴影)--远低于shadowmap的Drawcall,不需要每帧把场景多渲染一次,更低的GPU消耗
    - shadow map cache
    - Light culling
    - 每个动态光是否cast shadow
    - 局部烘焙Lightmass
<br/>

* ## **细节:AO/法线**
  + SSAO/DFAO
    - 不容易表达复杂层级的AO--精度问题,表现不够好
    - 比如衣服的褶皱,树叶之间的遮蔽效果都不够好
  + AO正常下低精度,有时候需要高精度
    - 物件的AO非常重要
    - 阴影区域下的树叶需要影中影
    - 有时候可以用shadowmap模拟/代替ao
  + 好的建模与法线为物体带来更好细节阴影(比如树叶的建模和法线)
  + 高精度AO直接烘焙到物体上
<br/>

* ## **UE5(猜测)**
  + 视频者的知乎:https://www.zhihu.com/question/394654035/answer/1222035601
  + Lumen
    - 结合多种技术的综合GI方案
      - Screen Space 细节
      - Distance Field 中距离
      - Voxel远距离
  + Nanite
    - 亿级面数模型成为可能
    - Micro Shadow
<br/>

------------------------
<span id='3'/>

## **3. 手游的优化**
* ## **手游的问题**
  + 主流:No SSAO , 有限制使用Shadow map
  + 手机GPU
    - 有Tile Base 特性
    - 浮点运算能力相对可以,带宽较低
      - 导致Deferred rendering成为非主流
      - Depth/GBuffer based 随机采样算法代价大(如SSAO)
  + 开始流行高清高帧率(如王者荣耀,吃鸡)但是又要尽可能低能耗低发热
    - Tile base 的on-chip特性
    - 带宽的重要的耗电来源
<br/>

* ## **手游的一些做法**
  + Vain Glory(虚荣)
    - 分离透明物体和不透明物体区域
      - 减少overdraw区域
      - 使用alpha blend实现抗锯齿(软边过渡)
      - 不透明区域更容易规避透明排序
    - 远景:把光照烘焙到diffuse(albedo)贴图上
      - 可以提供无限视距的光照阴影
      - 预先烘焙多角度
      - 类似unlit,节省了ALU
      - 性能消耗比lightmap更省(少了渲染shadowmap,tex2D shadowmap,和shadowmap的内存占用)
  + 黑色沙漠 
    - 直接光+shadowmap
      - 首次绘制shadowmap,之后的根据矩阵推算.移动一定距离,重新绘制新的shadowmap
    - 烘焙
      - 仅烘焙低精度的GI diffuse
      - 放弃烘焙AO,靠shadowmap补充
  + Zen Garden
    - 针对固定的方向光做烘焙
      - 高品质高性能
  + 其他
    - 通过Shader造假,产生Material光影
        - 高性价比,高性能(消耗比Fourier Opacity Map(PC Only)小很多很多)
        - 解决shadowmap不能覆盖的领域,如:透明物体,天空云,远景
        - 如瀑布的假阴影和假光照,解决透明光影问题
    - 2D ray march对一些面片粒子做阴影效果,比如:烟雾
    - 用面片做假的体积光
    - Fake AO,传入玩家坐标让地面/草面变黑,造成AO的感觉
    - 大量的的Micro lighting(光照表现)无法在光照管线上表达,只能在shading model(光照模型)上实现
      - SSS
      - Double Lobe Specular
      - Eye
      - Hair
      - Fiber(Moss)
      - Cloth
      - ......
<br/>

https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/Vulkan%20%E8%BF%9B%E9%98%B6/Subpass/Subpass%20%E5%88%9D%E6%AD%A5.html

------------------------
<span id='4'/>

## **4. 更新**
1. ## **Group -> Content Packing & Loading**
    + 打包和加载的地址
2. ## **Group -> Build Remote Catalog**
    + 勾选会产生catalog_版本号.hash 和 catalog_版本号.json(映射关系的资源目录)
    + 不勾选,产生的setting.json只有内部的catalog,且没有依赖
    + 勾选,产生的setting.json有本地Hash,服务器Hash,有依赖的catalog
3. 资源更新的API
    + GetDownloadSizeAsync(keys),可以计算出更新量
    + DownloadDependenciesAsync(keys)
      - 本地没有key映射的资源,则先下载到本地再加载
      - 如果本地有,则直接加载
    + key的选取:程序约定,从服务器获取,遍历catalog所有的key
4. 资源更新流程
    1. https://blog.csdn.net/u011366226/article/details/104506802/
    2. 注意使用 yield IEnumerator StartCoroutine
    3. Addressables.InitializeAsync,初始化
    4. Addressables.CheckForCatalogUpdates,获取Catalog是否更新
    5. Addressables.UpdateCatalogs,更新Catalog
    6. Addressables.GetDownloadSizeAsync(keys),获取更新的资源大小
    7. Addressables.DownloadDependicesAsync(keys,MergeMode.Union,true),下载更新资源
<br/>

------------------------

<span id='5'/>

## **5. 实战对比**

* ## **大地型包体**
    | 如| AssetBundle  |  Addressable  |
    | ---- | ---- | ---- |
    | AB数量 | 102 | 103(多了一个内置资源) |
    | 总Size大小 | 16.9MB(冗余) | 13.9 |
<br/>

* ## **加载**
  + AssetBundle
    - 得到所属的AB Path
    - 加载AB
    - 加载资源
    - 卸载ab.unload(false)
  + Addressable
    - Addressable.LoadAssetAsync,加载
<br/>

* ## **卸载**
  + AssetBundle
    - 自己统计计数,卸载AB包
    - 自己卸载深度依赖的AB包
  + Addressable
    - Addressables.Release,但是卸载CPU高
<br/>

* ## **总体**
  + Addressable
  + 优点
    - 总体FPS高
    - 简洁,只用关心key+type+handle就好了
    - 不用关AssetBundle 和 依赖关系
    - 可视化查看内存中的AssetBundle
    - 可以分析冗余
  + 缺点
    - 卸载CPU高,因为要处理依赖,计数器
    - 内存占用稍微高点,catalog.json占用问题
    - 不够灵活,如不能让某个AssetBundle常驻内存
<br/>

------------------------

<span id='6'/>

## **6. 其他**
1. ## **SendProfilerEvents**
    + 查看Profiler用
    + Release时,要关闭,否则堆内存会上去很多,耗时也会上去
2. ## **地形渲染成紫色**
    + 原因:Native/Terrain/Diffuse的Shader不一定会打包进去
    + 解决一:在场景中添加一个隐藏的Terrain
    + 解决二:Graphics Setting -> Always Included Shaders
    + 解决三:Shader Variant Collection(SVC) + Graphics Setting->Preloaded Shader
3. ## **从AssetBundle转Addressable**
    + Addressable->Tools->Convert Legacy AssetBundles
    + StreamAsset资源变成Group,但是是一次性的不可逆的
4. ## **Addressable学习Tips**
    + 把Addressable从Packages剪切到Asset,代码可以就可以编辑和更好地跳转了

------------------------