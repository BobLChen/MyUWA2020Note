**《天谕》手游的内存控制**
=================

(Github正常排版: [《天谕》手游的内存控制](TODO:))

------------------------

[1. 真实感](#1)<br>
[2. 光照](#2)<br>
[3. 手游的优化](#3)<br>
[4. 锯齿](#4)<br>

------------------------
<span id='1'/>

## **1. 资源内存**
* ## **Profiler工具**
  + Unity
    - Unity Profiler
      - Memory->Take Sample Playmode(可以查看当前资源的内存占用)
      - 新版本增加了Profiler (Standalone Process)(https://blog.csdn.net/zhenghongzhi6/article/details/106949795)
      - Profile Analyer(package manager)
    - Memory Profiler(package manager)
      - https://www.cnblogs.com/lucater/p/12509219.html
    - 抓帧:Frame Debugger
  + ios
    - xcode
    - 抓帧:xcode中的Instruments(https://www.jianshu.com/p/4d94a700de96)
  + android
    - 命令行dump(https://blog.csdn.net/jscese/article/details/37928823)
    - Android Studio->Profiler
    - 抓帧:Snapdragon(不同芯片可能不一样)/Renderdoc

<br/>

* ## **贴图**
  ### 贴图是内存和包体的大头
  + 格式:
    - 默认是ASTC8x8,部分需要高清用6x6或4x4(ASTC高质量,高压缩比,解析快,参数灵活)
    - ios放弃iphone5s/ipadmini
    - android给低端机单独打包(ETC2 8bits)
  + 尺寸:
    - 控制贴图尺寸,针对不同类型的尺寸缩放不同
    - 如:Albedo对尺寸敏感较低,可缩小.Normal需要高清,则放大
  + mipmap:
    - UI关闭mipmap,否则多33%的占用
  + Read/Write:
    - 关闭贴图的Read/Write Enaled,否则CPU和GPU会各有一份内存
  + 张数:
    - 去掉重复冗余贴图,减少张数(用UWA检测)
    - 合并通道(ASTC是按照block压缩的,对通道影响不大)
<br/>

* ## **Mesh**
  + 顶点数:
    - 控制网格的顶点数量和三角面数量(减面)
    - meshLod可以有效降低内存
  + 顶点属性:
    - 去掉不用的顶点属性(UV,Color等)
  + Read/Write:
    - 关闭Mesh的Read/Write
<br/>

* ## **动画**
  + 帧率:
    - 动画帧率30基本够了
  + 时长:
    - 严格控制动画的时长
  + 压缩:
    - 去除没有用到的动画属性,如单纯的位移动画应该去掉scale曲线
    - 减少keyframe
    - 压缩浮点精度
    - humanoid动画比generic动画占用要小
    - unity的压缩Optimal,默认误差是2,2,2(http://www.manew.com/thread-103127-1-1.html)
  + 数量:
    - 尽量复用动画资源(Retarget)
  + 其他:
    - Animator Controller会一下子加载全部的动画资源,需要优化(后面讲到)
<br/>

* ## **其他**
  + 中文字体库裁剪(FontCreator+FontSubsetPack)(12M->3M)
  + RenderTexture张数(复用),尺寸,格式
  + AssetBundle去掉TypeTree,TypeTree是不同版本格式兼容用的,正常用不到
  + 音频优化(通道/码率/streaming/按需加载)
  + 常驻内存,只读的(如数据文件,Dll等).当内存不够时,会使用磁盘变成虚拟内存,优化时可以稍微放一放.
<br/>

------------------------
<span id='2'/>

## **2. 脚本**
* ## **Mono/Lua GC优化**
  + 控制高频内存优化
  + 控制大块的内存申请
  + 控制容易导致GC Alloc的函数调用
    - [Mono]字符串拼接/ToString/ToArray
    - [Mono]Tag/Name/Mesh.Vertices(normal uvs)/SkinedMeshRenderer.bones
    - [Mono]Boxing/委托/匿名函数
    - [Lua]Vector/Color等对象
    - Log输出
  + 缓存和复用
  + 合适的时机卸载和回收
<br/>

* ## **举个栗(例)子**
  + 避免Update,LateUpdate等函数中频繁调用某些方法
    - GetComponent(),FindObjectsOfType()等
    - 给栈上的数组赋值,会触发堆内存的反复分配(https://blog.csdn.net/lcl19970203/article/details/54428358)
    - 避免使用GameObject.Tag,GameObject.Name进行比较,用CompareTag进行tag比较.
    - 避免Camera.main,Camera.main实际为GameObject.FindGameObjectsWithTag(“MainCamera”)但是但是但是Unity 2020.2 beta之后Camera.main就被优化了(https://mp.weixin.qq.com/s/JvzhMkEK_dXTxqIRL6-4LA)
  + 避免反复调用alloc->accessors,如:Mesh.Vertices/Normals/UVS,SKinMeshRenderer.bones
  + 避免频繁调用int.tostring()及其其他类型的衍生,可以使用map缓存代替(https://blog.csdn.net/iteye_14970/article/details/82341552)
  + 避免OnGUI的调用,否则UIEvents.IMGUIRenderOverlays会产生GC(https://zhuanlan.zhihu.com/p/94017669)
  + 避免频繁打印Log,可以用LogLevel,对于发布版本进行区分
  + 避免使用枚举或struct作为字典的key进行查找,因为没有实现IEquatable,Enum要转换为Object,则会boxing(https://blog.csdn.net/zhaogenzi/article/details/9361349)
  + 尽量避免使用dict.values,可以直接遍历取到value即可
  + 使用yield尽量复用waitXX对象,可以使用自己写个yield.cs管理,而不是每次new
  + 频繁创建和更新的字符串尽量缓存,比如CD时间
  + 用RayCastNonAlloc代替RayCast
  + 用yield return null代替yield return 0
  + 尽量少用创建带upvalue的lambda,因为这个对象会产生124B的GC,禁止在for循环和update中使用
  + 委托有+=务必有-= 或者 =null,另外禁止太长的委托调用链
  + 避免string过多的+=,过多可以用StringBuilder/String.Format代替
  + 协程Coroutine,开启一个协程,至少分配373的内存
  + 用.NameContains(自己扩展引擎的接口),来代替shader/gameobject/component的name.Contains,因为有临时内存(39B的堆内存)分配有GC(https://blog.csdn.net/weixin_45979158/article/details/104242969)
<br/>

* ## **代码C++化**
  ### 把一些模块代码写成C++,不过C#也有unsafe
  + why
    - 提高运算性能
    - 减少频繁操作调用导致的GC
  + what
    - xml文件
    - 网络包处理
    - 属性和战斗计算
    - 数据表压缩
  + 缺点
    - 不能热更新
<br/>

* ## **数据表压缩(C++实现)**
  + why
    - 提高运算性能
    - 减少频繁操作调用导致的GC
  + what
    - xml文件
    - 网络包处理
    - 属性和战斗计算
    - 数据表压缩
  + 缺点
    - 不能热更新
<br/>

* ## **动态物体光照**
  + Capsule Shadow
    - https://www.unrealengine.com/zh-CN/blog/chn-unreal-engine-4-light-and-shadow
    - Capsule数据容易存储,ray march中容易计算
    - 实现软间接shadow(支持影中影)
    - 对静态Distance Field的补充
<br/>


* ## **动态管线的TradeOff**
  + 动态管线真的慢吗?
    - Fortnite(堡垒之夜)
    - 取决于使用了什么特性,场景物件的把控
  + 动态效果不如Lightmass吗?
    - 暂时缺乏高品质GI,需要手动补光
    - 合理运用特性(DFAO),AO精度和表达不是问题
  + 灵活运用各种手段
    - DFRTS(用距离场算阴影)--远低于shadowmap的Drawcall,不需要每帧把场景多渲染一次,更低的GPU消耗
    - shadow map cache
    - Light culling
    - 每个动态光是否cast shadow
    - 局部烘焙Lightmass
<br/>

* ## **细节:AO/法线**
  + SSAO/DFAO
    - 不容易表达复杂层级的AO--精度问题,表现不够好
    - 比如衣服的褶皱,树叶之间的遮蔽效果都不够好
  + AO正常下低精度,有时候需要高精度
    - 物件的AO非常重要
    - 阴影区域下的树叶需要影中影
    - 有时候可以用shadowmap模拟/代替ao
  + 好的建模与法线为物体带来更好细节阴影(比如树叶的建模和法线)
  + 高精度AO直接烘焙到物体上
<br/>

* ## **UE5(猜测)**
  + 视频作者的知乎回答:https://www.zhihu.com/question/394654035/answer/1222035601
  + Lumen
    - 结合多种技术的综合GI方案
      - Screen Space 细节
      - Distance Field 中距离
      - Voxel远距离
  + Nanite
    - 亿级面数模型成为可能
    - Micro Shadow
<br/>

------------------------
<span id='3'/>

## **3. 手游的优化**
* ## **手游的问题**
  + 主流:No SSAO , 有限制使用Shadow map
  + 手机GPU
    - 有Tile Base 特性
    - 浮点运算能力相对可以,带宽较低
      - 导致Deferred rendering成为非主流
      - Depth/GBuffer based 随机采样算法代价大(如SSAO)
  + 开始流行高清高帧率(如王者荣耀,吃鸡)但是又要尽可能低能耗低发热
    - Tile base 的on-chip特性
    - 带宽是重要的耗电降频来源
<br/>

* ## **Subpass**
  + https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/Vulkan%20%E8%BF%9B%E9%98%B6/Subpass/Subpass%20%E5%88%9D%E6%AD%A5.html
  + 一个on chip tile的数据可以在多次绘制中共享,减少带宽消耗
  + 后一个 subpass 所使用的 attachments 的像素可以直接从前一个 subpass 的 attachments 中的对应位置读取
  + 每次绘制不会立即把数据输出到framebuffer
  + 但不能对临近像素进行采样了,只能使用同一位置的像素信息
  + 典型应用:on chip buffer , subpass让高性能的Deferred Rendering成为可能
  + 硬件API:Vulkan/Metal
<br/>

* ## **手游的一些做法**
  + Vain Glory(虚荣)
    - 分离透明物体和不透明物体区域
      - 减少overdraw区域
      - 使用alpha blend实现抗锯齿(软边过渡)
      - 不透明区域更容易规避透明排序
    - 远景:把光照烘焙到diffuse(albedo)贴图上
      - 可以提供无限视距的光照阴影
      - 预先烘焙多角度
      - shader类似unlit,节省了ALU
      - 性能消耗比lightmap更省(少了渲染shadowmap,tex2D shadowmap,和shadowmap的内存占用)
  + 黑色沙漠 
    - 直接光+shadowmap
      - 首次绘制shadowmap,之后的根据矩阵推算.移动一定距离,重新绘制新的shadowmap
    - 烘焙
      - 仅烘焙低精度的GI diffuse
      - 放弃烘焙AO,靠shadowmap补充
  + Zen Garden
    - 针对固定的方向光做烘焙
      - 高品质高性能
  + 其他
    - 通过Shader造假,产生Material光影
        - 高性价比,高性能(消耗比Fourier Opacity Map(PC Only)小很多很多)
        - 解决shadowmap不能覆盖的领域,如:透明物体,天空云,远景
        - 如瀑布的假阴影和假光照,解决透明光影问题
    - 2D ray march对一些面片粒子做阴影效果,比如:烟雾
    - 用面片做假的体积光
    - Fake AO,传入玩家坐标让地面/草面变黑,造成AO的感觉
    - 大量的的Micro lighting(光照表现)无法在光照管线上表达,只能在shading model(光照模型)上实现
      - SSS
      - Double Lobe Specular
      - Eye
      - Hair
      - Fiber(Moss)
      - Cloth
      - ......
<br/>

------------------------
<span id='4'/>

## **4. 锯齿**
* ## **原因**
    + 几何锯齿
      - 尖锐细小的物体
      - Alpha Test
    + Shading 锯齿
      - 高频的Normal变化
      - HDR亮度
* ## **资源侧抗锯齿**
    + Alpha Blend
    + Normal/Roughness Composite
      - 根据法线去修改roughness,在边缘等地方提高roughness,使其看起来不尖锐
      - 对抗Shading alias
      - 移动端更有优势
    + mipmap
      - UE4的sharpen功能--锐化效果
      - 不要乱用no mipmap
* ## **Temporal Antialising(TAA)**
    + PS4主流抗锯齿
      - 将超采样的流程中分到几帧中运算
      - 可以轻易达到16x的级别的超采样样本
      - 有效对抗shading aliasing
    + 额外功能:animated alpha dither
      - 使用alpha test模拟半透明
    + 问题
      - 残影
        - 需要velocity信息去resolve
      - 过度模糊
        - sharpening
        - mimap增强
        - Temporal upsample(针对低分辨率)
      - 替代方案
        - NVIDIA:DLSS(深度学习超级采样)
        - AMD:CAS(对比度感知锐化)+RIS(Radeon图像锐化)
<br/>

------------------------
